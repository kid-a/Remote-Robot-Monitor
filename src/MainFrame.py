# -*- coding: utf-8 -*-
# generated by wxGlade 0.6.3 on Thu Feb 12 13:23:43 2009

import wx
import thread

# begin wxGlade: dependencies
import wx.grid
# end wxGlade

# begin wxGlade: extracode
import Table
import sys
from ConnectDialog import ConnectDialog
from RobotStatus import RobotStatus
# end wxGlade

##NAVIGATION MODE
IO_SFL = 1
ABSOLUTE = 2

##SOCKET CONSTANTS
NOT_CONNECTED = 0
CONNECTED = 2
CONNECTING = 1
ERROR = -1
SEND_TRAJ = 3
STOP = 4

## TABLE STATUS FLAGS
DRAGGING = 1
IDLE = 0

## FILE CONSTANTS ##
NONE = 0
OPEN_REQUESTED = 1
SAVE_REQUESTED = 2

RESET = 6
MODIFYING = 2
NOT_MODIFIED = 0
ADDED_POINT = 5
MOVED_POINT = 1
UNDO_REQUESTED = 3
REDO_REQUESTED = 4


class CustomStatusBar(wx.StatusBar):
    def __init__(self, parent):
        wx.StatusBar.__init__(self, parent)
            
        self.SetFieldsCount(2)
        self.Bind(wx.EVT_SIZE, self.OnSize)
        self.icon = wx.StaticBitmap(self, -1, wx.Bitmap('icons/network-offline.png'))
        #self.SetDisconnected()
        
    def PlaceIcon(self):
        rect = self.GetFieldRect(1)
        self.icon.SetPosition((rect.x+3, rect.y+3))

    def OnSize(self, event):
        self.PlaceIcon()

    def SetConnected(self,IP):
        self.SetStatusText('     Connected to'+IP , 1)
        self.icon = wx.StaticBitmap(self, -1, wx.Bitmap('icons/network-transmit-receive.png'))
        self.PlaceIcon()
            
    def SetNotconnected(self):
        self.SetStatusText('     Not Connected', 1)
        self.icon = wx.StaticBitmap(self, -1, wx.Bitmap('icons/network-offline.png'))
        self.PlaceIcon()                  

class MainFrame(wx.Frame):
    def __init__(self, parentFrame, id, mementoCondition, socketCondition, fileCondition, title):
        # begin wxGlade: MainFrame.__init__
        wx.Frame.__init__(self, parentFrame, id, title, style = wx.DEFAULT_FRAME_STYLE)
        self.splitterWindow = wx.SplitterWindow(self, -1, style=wx.SP_3D|wx.SP_BORDER)
        self.window_1 = wx.SplitterWindow(self.splitterWindow, -1, style=wx.SP_3D|wx.SP_BORDER)
        self.window_1_pane_2 = wx.Panel(self.window_1, -1)
        self.sizer_5_staticbox = wx.StaticBox(self.window_1_pane_2, -1, "Options")
        self.sizer_4_staticbox = wx.StaticBox(self.window_1_pane_2, -1, "Navigation")
        
        # Menu Bar
        self.MainMenuBar = wx.MenuBar()
        self.File = wx.Menu()
        save = wx.MenuItem(self.File,1,'&Save Trajectory\tCtrl+S')
        save.SetBitmap(wx.Bitmap('icons/open.png'))
        load = wx.MenuItem(self.File,2,'&Load Trajectory\tCtrl+L')
        load.SetBitmap(wx.Bitmap('icons/save.png'))
        quit = wx.MenuItem(self.File, 3, '&Quit\tCtrl+Q')
        quit.SetBitmap(wx.Bitmap('icons/quit.png'))
        self.File.AppendItem(save)
        self.File.AppendItem(load)
        self.File.AppendItem(quit)
        self.MainMenuBar.Append(self.File, "File")
        
        self.Actions = wx.Menu()
        self.undo = wx.MenuItem(self.Actions, 11, '&Undo\tCtrl+Z')
        self.undo.SetBitmap(wx.Bitmap('icons/edit-undo.png'))
        self.redo = wx.MenuItem(self.Actions, 12, '&Redo\tCtrl+W')
        self.redo.SetBitmap(wx.Bitmap('icons/edit-redo.png'))
        reset_traj = wx.MenuItem(self.Actions, 13, '&Reset Trajectory\tCtrl+R')
        reset_traj.SetBitmap(wx.Bitmap('icons/revert.png'))
        connect = wx.MenuItem(self.Actions, 14, '&Connect\tCtrl+C')
        connect.SetBitmap(wx.Bitmap('icons/connect.png'))
        release = wx.MenuItem(self.Actions, 15, '&Stop Connection\tCtrl+B')
        release.SetBitmap(wx.Bitmap('icons/connection_stop.png'))
        self.show_robot_status = wx.MenuItem(self.Actions, 16, '&Show Robot Status\tCtrl+T')
        self.show_robot_status.SetBitmap(wx.Bitmap('icons/Robot_little.png'))
        self.Actions.AppendItem(self.undo)
        self.Actions.AppendItem(self.redo)
        self.Actions.AppendItem(reset_traj)
        self.Actions.AppendItem(connect)
        self.Actions.AppendItem(release)
        self.Actions.AppendItem(self.show_robot_status)
        self.MainMenuBar.Append(self.Actions,"Actions")

        self.Help = wx.Menu()
        about = wx.MenuItem(self.Help, 21,'About\t')
        about.SetBitmap(wx.Bitmap('icons/Robot_little.png'))
        self.Help.AppendItem(about)
        self.MainMenuBar.Append(self.Help,"Help")
        
        self.SetMenuBar(self.MainMenuBar)

        self.Bind(wx.EVT_MENU, self.OnQuit, id = 3)
        self.Bind(wx.EVT_MENU, self.OnLoad, id = 2)
        self.Bind(wx.EVT_MENU, self.OnSave, id = 1)
        self.Bind(wx.EVT_MENU, self.OnTrajReset, id = 13)
        self.Bind(wx.EVT_MENU, self.OnUndo, id = 11)
        self.Bind(wx.EVT_MENU, self.OnRedo, id = 12)
        self.Bind(wx.EVT_MENU, self.OnConnect, id = 14)
        self.Bind(wx.EVT_MENU, self.OnShowRobotStatus, id = 16)
        self.Bind(wx.EVT_MENU, self.OnAbout, id = 21)
        self.Bind(wx.EVT_CLOSE,self.OnChiudi)
        
        # Menu Bar end
#        self.MainStatusBar = self.CreateStatusBar(2, 0)
        self.MainStatusBar = CustomStatusBar(self)
        self.SetStatusBar(self.MainStatusBar)
        self.table = Table.Table(self.window_1, self.MainStatusBar, self, -1)
        self.stop_button = wx.Button(self.window_1_pane_2, -1, "STOP")
        self.stop_button.SetToolTip(wx.ToolTip("click to immediately stop the robot"))
        self.start_button = wx.Button(self.window_1_pane_2, -1, "START")
        self.start_button.SetToolTip(wx.ToolTip("click to start the trajectory"))
        self.iosfl = wx.RadioButton(self.window_1_pane_2, -1, "IO-SFL")
        self.absolute_navigation = wx.RadioButton(self.window_1_pane_2, -1, "absolute")
        self.obstacle_avoidance = wx.CheckBox(self.window_1_pane_2, -1, "obstacle avoidance")
        self.beacons_triang = wx.CheckBox(self.window_1_pane_2, -1, "beacons")
        self.GridList = wx.grid.Grid(self.splitterWindow, -1, size=(1, 1))
        self.GridLength = 0

        ### MUTEX AND COND VARS ###
        self.grid_mutex = thread.allocate_lock()
        self.connection_mutex = thread.allocate_lock()
        self.mementoCondition = mementoCondition
        self.socketCondition = socketCondition
        self.fileCondition = fileCondition
        ### MUTEX AND COND VARS END ###

        self.file_status = NONE
        self.grid_status = NOT_MODIFIED
        self.socket_command = NOT_CONNECTED
        
        self.__set_properties()
        self.__do_layout()
        # end wxGlade

    def __set_properties(self):
        # begin wxGlade: MainFrame.__set_properties
        self.SetTitle("Remote Robot Monitor")
        _icon = wx.EmptyIcon()
        _icon.CopyFromBitmap(wx.Bitmap("icons/Robot.png", wx.BITMAP_TYPE_ANY))
        self.SetIcon(_icon)
        self.SetSize((919, 600))
        self.MainStatusBar.SetStatusWidths([600, 300])
        MainStatusBar_fields = ["Remote Robot Monitor - beta 2", "     Not Connected"]
        for i in range(len(MainStatusBar_fields)):
            self.MainStatusBar.SetStatusText(MainStatusBar_fields[i], i)
        self.table.SetMinSize((606, 420))
        self.stop_button.SetMinSize((300, 55))
        self.stop_button.SetBackgroundColour(wx.Colour(255, 0, 0))
        self.stop_button.SetFont(wx.Font(20, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, "Sans"))
        self.start_button.SetMinSize((300, 55))
        self.start_button.SetBackgroundColour(wx.Colour(0, 255, 0))
        self.start_button.SetFont(wx.Font(20, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, "Sans"))

        self.start_button.Bind(wx.EVT_BUTTON,self.OnStart)
        self.stop_button.Bind(wx.EVT_BUTTON,self.OnStop)
        
        self.window_1_pane_2.SetMinSize((606, 178))
        self.window_1.SetMinSize((606, 603))
        self.GridList.CreateGrid(20, 2)
        self.GridList.SetRowLabelSize(30)
        self.GridList.SetColLabelSize(30)
        self.GridList.SetColLabelValue(0, "X")
        self.GridList.SetColSize(0, 130)
        self.GridList.SetColLabelValue(1, "Y")
        self.GridList.SetColSize(1, 130)
        self.GridList.SetMinSize((308, 623))

        self.SetUndo(False)
        self.SetRedo(False)
        self.Bind(wx.grid.EVT_GRID_CELL_CHANGE, self.OnCellEdit)
        self.Bind(wx.grid.EVT_GRID_EDITOR_SHOWN, self.PriorCellEdit)
        
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: MainFrame.__do_layout
        MainSizer = wx.BoxSizer(wx.VERTICAL)
        grid_sizer_4 = wx.FlexGridSizer(2, 2, 0, 0)
        sizer_5 = wx.StaticBoxSizer(self.sizer_5_staticbox, wx.HORIZONTAL)
        grid_sizer_6 = wx.FlexGridSizer(2, 1, 0, 0)
        sizer_4 = wx.StaticBoxSizer(self.sizer_4_staticbox, wx.HORIZONTAL)
        grid_sizer_5 = wx.FlexGridSizer(2, 1, 0, 0)
        grid_sizer_4.Add(self.stop_button, 0, wx.ADJUST_MINSIZE, 0)
        grid_sizer_4.Add(self.start_button, 0, wx.ADJUST_MINSIZE, 0)
        grid_sizer_5.Add(self.iosfl, 0, wx.ADJUST_MINSIZE, 0)
        grid_sizer_5.Add(self.absolute_navigation, 0, wx.ADJUST_MINSIZE, 0)
        sizer_4.Add(grid_sizer_5, 1, wx.EXPAND, 0)
        grid_sizer_4.Add(sizer_4, 1, wx.EXPAND, 0)
        grid_sizer_6.Add(self.obstacle_avoidance, 0, wx.ADJUST_MINSIZE, 0)
        grid_sizer_6.Add(self.beacons_triang, 0, wx.ADJUST_MINSIZE, 0)
        sizer_5.Add(grid_sizer_6, 1, wx.EXPAND, 0)
        grid_sizer_4.Add(sizer_5, 1, wx.EXPAND, 0)
        self.window_1_pane_2.SetSizer(grid_sizer_4)
        self.window_1.SplitHorizontally(self.table, self.window_1_pane_2, 420)
        self.splitterWindow.SplitVertically(self.window_1, self.GridList, 606)
        MainSizer.Add(self.splitterWindow, 1, wx.EXPAND, 0)
        self.SetSizer(MainSizer)
        self.Layout()
        self.SetSize((919, 600))
        self.Centre()
        # end wxGlade

    def SetStatusBarConnected(self,IP):
        self.MainStatusBar.SetConnected(IP)

    def SetStatusBarNotConnected(self):
        self.MainStatusBar.SetNotConnected()

    def DisplayConnectionWarning(self):
        errorDialog = wx.MessageDialog(self,"Connection reset.","Warning",style = wx.OK | wx.ICON_EXCLAMATION)
        errorDialog.ShowModal()        
        
    def GetNavMode(self):
        if self.iosfl.GetValue():
            return IO_SFL
        else:
            return ABSOLUTE

    def GetNavOptions(self):
        return (self.obstacle_avoidance.GetValue(),self.beacons_triang.GetValue())

    def SetUndo(self,bool):
        self.grid_mutex.acquire()
        self.undo.Enable(bool)
        self.grid_mutex.release()

    def SetRedo(self,bool):
        self.grid_mutex.acquire()
        self.redo.Enable(bool)
        self.grid_mutex.release()

    def GetConnectionDialog(self):
        return self.dialog

    def GetTable(self):
        return self.table

    def SetSocketStatus(self,value):
        self.socket_command = value

    def GetCommand(self):
        return self.socket_command

    def GetGridStatus(self):
        self.grid_mutex.acquire()
        status = self.grid_status
        self.grid_mutex.release()
        return status

    def SetGridStatus(self,new_status):
        self.grid_mutex.acquire()
        self.grid_status = new_status
        self.grid_mutex.release()

    def GetGridValues(self):
        self.grid_mutex.acquire()
        list_to_return = []
        for i in range (self.GridLength):
            list_to_return.append((self.GridList.GetCellValue(i,0),self.GridList.GetCellValue(i,1)))
        #self.grid_status = NOT_MODIFIED
        self.grid_mutex.release()
        return list_to_return

    def AddGridValue(self,point):
        self.grid_mutex.acquire()
        self.grid_status = MODIFYING
        self.GridList.SetCellValue(self.GridLength,0,str(point[0]))
        self.GridList.SetCellValue(self.GridLength,1,str(point[1]))
        self.GridLength += 1 
        self.grid_status = ADDED_POINT
        self.grid_mutex.release()
        self.mementoCondition.acquire()
        self.mementoCondition.notify()
        self.mementoCondition.release()
        self.SetUndo(True)
        self.Refresh()

    def SetGridValues(self,points_list):
        self.grid_mutex.acquire()
        self.grid_status = MODIFYING
        self.GridList.ClearGrid()
        self.GridLength = 0
        for point in points_list:
            self.GridList.SetCellValue(self.GridLength,0,str(point[0]))
            self.GridList.SetCellValue(self.GridLength,1,str(point[1]))
            self.GridLength += 1 
        self.grid_status = ADDED_POINT
        self.grid_mutex.release()
        self.mementoCondition.acquire()
        self.mementoCondition.notify()
        self.mementoCondition.release()
        self.Refresh()
        self.SetUndo(True)

    def OnTrajReset(self,evt):
        self.grid_mutex.acquire()
        #self.GridList.ClearGrid()
        #self.GridLength = 0
        self.grid_status = RESET
        self.grid_mutex.release()
        self.mementoCondition.acquire()
        self.mementoCondition.notify()
        self.mementoCondition.release()
        self.Refresh()
        self.SetUndo(True)

    def SetPointMoved(self,index,new_point,tableStatus,oldPoint):
        self.grid_mutex.acquire()
        self.GridList.SetCellValue(index,0,str(new_point[0]))
        self.GridList.SetCellValue(index,1,str(new_point[1]))
        if tableStatus == DRAGGING:
            self.grid_status = MOVED_POINT
        self.grid_mutex.release()
        if tableStatus == IDLE:
            self.moved_point_info = [index,oldPoint,new_point]
            self.mementoCondition.acquire()
            self.mementoCondition.notify()
            self.mementoCondition.release()
            self.SetUndo(True)
        self.Refresh()

    def GetMovedPointInfo(self):
        return self.moved_point_info

    def PriorCellEdit(self,evt):
        self.PointBackupValue = (
            self.GridList.GetCellValue(evt.GetRow(),0),
            self.GridList.GetCellValue(evt.GetRow(),1))

    def OnCellEdit(self,evt):
        if evt.GetRow() < self.GridLength:
            point = (self.GridList.GetCellValue(evt.GetRow(),0),self.GridList.GetCellValue(evt.GetRow(),1))
            if (point[0] >= 0 and point[0]<=3000) and (point[1] >= 0 and point[1] <= 2100):
                self.grid_mutex.acquire()
                self.grid_status = MOVED_POINT
                self.grid_mutex.release()
                self.moved_point_info = [evt.GetRow(),self.PointBackupValue,(self.GridList.GetCellValue(evt.GetRow(),0),self.GridList.GetCellValue(evt.GetRow(),1))]
                self.mementoCondition.acquire()
                self.mementoCondition.notify()
                self.mementoCondition.release()
                self.Refresh()
                self.SetUndo(True)
            else:
                self.GridList.SetCellValue(evt.GetRow(),0,self.PointBackupValue[0])
                self.GridList.SetCellValue(evt.GetRow(),1,self.PointBackupValue[1])
                errorDialog = wx.MessageDialog(self,"It is not possible to select point outstanding the game table.","Error",style = wx.OK | wx.ICON_ERROR)
                errorDialog.ShowModal()
        else:
            self.GridList.SetCellValue(evt.GetRow(),0,'')
            self.GridList.SetCellValue(evt.GetRow(),1,'')
                
    def OnUndo(self,evt):
        self.grid_mutex.acquire()
        self.grid_status = UNDO_REQUESTED
        self.grid_mutex.release()
        self.mementoCondition.acquire()
        self.mementoCondition.notify()
        self.mementoCondition.release()

    def OnRedo(self,evt):
        self.grid_mutex.acquire()
        self.grid_status = REDO_REQUESTED
        self.grid_mutex.release()
        self.mementoCondition.acquire()
        self.mementoCondition.notify()
        self.mementoCondition.release()

    def OnConnect(self,evt):
        self.dialog = ConnectDialog(self,-1,self.socketCondition)
        self.dialog.ShowModal()

    def GetPath(self):
        return (self.file_status,self.path)

    def OnShowRobotStatus(self,evt):
        robot_status = RobotStatus(None,-1,"")
        robot_status.SetSizeWH(300,300)
        robot_status.Show() 

    def OnLoad(self,evt):
        apertura=wx.FileDialog(self,message = 'OPEN FROM FILE',style = wx.FD_OPEN)
        apertura.Show(True)
        if apertura.ShowModal()==wx.ID_OK:
            self.path=apertura.GetPath()
            self.fileCondition.acquire()
            self.file_status = OPEN_REQUESTED
            self.fileCondition.notify()
            self.fileCondition.release()

    def OnSave(self,evt):
        salvataggio = wx.FileDialog(self,message = 'SAVE SESSION',style = wx.FD_SAVE)
        salvataggio.Show(True)
        if salvataggio.ShowModal()==wx.ID_OK:
            self.path=salvataggio.GetPath()
            self.fileCondition.acquire()
            self.file_status = SAVE_REQUESTED
            self.fileCondition.notify()
            self.fileCondition.release()

    def OnStart(self,evt):
        self.socketCondition.acquire()
        if self.GridLength == 0:
            errorDialog = wx.MessageDialog(self,"No trajectories to perform.\n Insert a trajectory, first.","Error",style = wx.OK | wx.ICON_ERROR)
            errorDialog.ShowModal()
            return
        if self.socket_command != CONNECTED:
            errorDialog = wx.MessageDialog(self,"Unable to perform the trajectory.\nCheck the connection.","Error",style = wx.OK | wx.ICON_ERROR)
            errorDialog.ShowModal()
            return
        self.socket_command = SEND_TRAJ
        self.socketCondition.notify()
        self.socketCondition.release()

    def OnStop(self,evt):
        self.socketCondition.acquire()
        self.socket_command = STOP
        self.socketCondition.notify()
        self.socketCondition.release()

    def OnQuit(self,evt):
        dial = wx.MessageDialog(None, 'Do you really want to quit?', '' , wx.YES_NO | wx.NO_DEFAULT | wx.ICON_QUESTION)
        answer = dial.ShowModal()
        if answer == wx.ID_YES: 
            sys.exit(0)

    def OnChiudi(self,evt):
        dial = wx.MessageDialog(None, 'Do you really want to quit?', '' , wx.YES_NO | wx.NO_DEFAULT | wx.ICON_QUESTION)
        answer = dial.ShowModal()
        if answer == wx.ID_YES: 
            sys.exit(0)

    def OnAbout(self,evt):
        description = """Remote Robot Monitor is an advanced control panel & telemetry system for mobile robots designed to take part to the Eurobot 2009 Contest. Features include trajectory planning and handling, navigation mode selection, sensors panel and - of course! - emergency stop button."""

        licence = """Remote Robot Monitor is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the Free Software Foundation; 
either version 2 of the License, or (at your option) any later version.

Remote Robot Monitor is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;   
See the GNU General Public License for more details. You should have received a copy of 
the GNU General Public License along with Remote Robot Monitor; if not, write to 
the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA"""

        info = wx.AboutDialogInfo()
        info.SetIcon(wx.Icon('icons/Robot.png', wx.BITMAP_TYPE_PNG))
        info.SetName('Remote Robot Monitor')
        info.SetVersion('1.0')
        info.SetDescription(description)
        info.SetCopyright('(C) UNICT TEAM for EUROBOT 2009')
        info.SetWebSite('http://eurobot.diit.unict.it')
        info.SetLicence(licence)
        info.AddDeveloper('Loris Fichera')
        info.AddDeveloper('Nicolo\' Grippaldi')
        #info.AddArtist('')
	#info.AddTranslator('')
        wx.AboutBox(info)

# end of class MainFrame
